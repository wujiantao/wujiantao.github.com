---
title: 位运算介绍一
layout: post
key: 8d02c20e-ef1e-4062-9f9f-ebdb0ee7fd76
tags:
  -bitwise_operation
  -algorithm
---


####一、原码、反码、补码介绍####

这里讨论的原码、反码和补码都是针对有符号数而言。

####1、原码####

对于一个符号数，在原码表示中通常将其最高位作为符号位，余下的位存储真值的绝对值，例如对于一个 8 位的有符号数，其原码表示如下。

> +1 0000 0001<br>
> -1 1000 0001

####2、反码####

对于一个有符号数，其反码表示也是将最高位作为符号位。对于正数余下的位和原码一样。对于负数余下的位则是在原码的基础上按位取反。例如对于 8 位的有符号数,其反码表示如下。

> +1 0000 0001<br>
> -1 1111 1110

####3、补码####

对于一个有符号数，正数的补码表示和其原码表示一致，但负数的补码表示是在其反码表示的基础上加1。例如对于8位的有符号数，其补码表示如下。

> +1 0000 0001<br>
> -1 1111 1111

####4、补码转原码####

如果我们有一个数的补码，我们希望得到他的原码，因为原码表示更直观。那么改如何转化？

首先对于正数而言，因为其补码就是原码，所以不需要作任何改变。

对负数而言，我们根据前面原码到补码的转换规则，很容易想到的就是，先将补码减1，然后保持符号位不变，其他位按位取反得到该数的原码。

这的确是一种正确的解码方式。但如果计算机中没有减法，只有加法，该怎么办呢？因为通常减去一个数。我们可以转化为加上该数的负数。所以我们可以在计算机中只保留加法，而不需要减法。

其实也可以将前面的解码操作中的减法转化为加法。

首先对于 n 位的有符号数 x 。对除符号位以外的所有位按位取反得到结果 y 。那么 y = (power(2 , n - 1) - 1) - x 

那么对于一个补码为 x 的有符号数，应用前面的解码操作得到其原码的值为 y , y = (power(2 , n - 1) - 1) - (x - 1) 。进行简单的变换，得到 y = (power(2 , n - 1) ) -  x + 1 。所以前面的解码操作可以变成先对补码除符号位以外的所有位按位取反。然后再对取反得到的结果加 1 。即为该补码的原码。

####4、用途####

为什么要不厌其烦的对数字进行三种编码表示呢？这主要是为了方便计算机的计算。计算机在计算过程中，对有符号数采用补码表示。这样表示的好处就是可以让有符号数的符号位参加运算。这样计算机就可以像对待普通位那样去对待符号位。而不用单独的去判断和处理符号位。这可以简化设计和计算。同时减法可以转化为对负数的加法。下面举例进行说明。

示例一

		char a = 0xFF; //二进制表示为 1111 1111
		printf("%d\n", a); //输出结果为-1,0xFF为-1的补码。

示例二

		char a = 0xFF; //二进制表示为 1111 1111
		char b = 0x02; //二进制表示为 0000 0010
		printf("%d\n", a + b); //输出结果为1,
		//补码累加结果为0000 0001。本来相加结果应为 1 0000 0001。
		//超出8位的进位被丢弃。所以最终结果为 0000 0001。

<div class="blank"></div>

####5、结语####

为什么要花较长的篇幅来介绍数的原码、反码和补码，一个原因是对以前知识进行回顾。第二个因为计算机中对有符号数的存储都是存储的该数的补码。如果对补码了解的不清楚，会对位运算的理解带来困难。接下来的位运算介绍二，将对具体的位运算实例进行介绍。

####6、引用####

[原码、反码、补码详解](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
