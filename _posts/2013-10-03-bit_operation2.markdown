---
title: 位运算介绍二
layout: post
key: d86f3273-2c31-45fb-af41-7b2f2e2e10f2
tags:
  -bitwise_operation
  -algorithm 
---


####基本操作####
位运算的基本操作有 与、或、非、异或、左移、右移。

但借助这些最基本的操作，能实现的功能却很多很多，有简单的也有复杂的。这里挑选几个简单的实例进行介绍。自己也借此机会一并学习。

#####实例一#####
把一个数的二进制表示中最右边为1的位变为0。

方法一

	char x = 0x14;		//x的二进制为0001 0100
	x = x & (x - 1);	//x的二进制为0001 0000

方法二

	char x = 0x14;
	x = x ^ (x & -x);
 	/* x & -x 取 x 中最右的位。即 00000100 。 x ^ (x & -x) 将最右边为 1 的位，置为 0 。
 	-x 是将 x 中的所有位先按位取反（包括符号位)。所以 x 中最右边为 0 的序列在 -x 中都为 1 。
	然后将取反的结果加 1 即为 -x 的补码。 -x 的补码中最右边为 1 的位和 x 是在同一位。
 	x & -x 取的是最右边为 1 的位。 x ^ (x & -x) 则将最右边为 1 的位，置为 0 。 */ 

<div class="blank"></div>
#####实例二#####
找出一个数的二进制表示中一共有多少位为1

方法一

	//利用实例一中的方法一。逐个消除最右边为1的位。
	int c = 0;
	char a = 0xAF; //二进制表示为 1010 1111
	while (a) {
		a = a & (a - 1);
		c++;
	}
	printf("%d\n", c);

方法二	

	//在百度百科上看到的
	x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);
	x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);
	x = (x & 0x0000FFFF) + ((x >>16) & 0x0000FFFF);
	printf("%d\n", x);
 	/*该方法初看比较难以理解。我们首先将 0x55555555二进制展开得到01010101010101010101010101010101 。
 	x & 0x55555555 就是看奇数位上有多少个为 1。( (x >> 1) & 0x55555555)就是看偶数位上有多少个为 1 。
	对于奇数 i , (x & 0x55555555) + ((x >> 1) & 0x55555555) 的结果的第 i 和第 i + 1 位组成的值，
	存储的是 x 中 第 i 位和第 i + 1 位中 1 的个数。同理对于如下的几个式子作类似分析。直到最后将
	高 16 位中 1 的个数和低 16 位中 1 的个数相加。存储到这 32 位中（但由于结果小于等于 32 所有所
	用的位数很少） */ 

<div class="blank"></div>
#####实例三#####
算出一个数的二进制表示中为1的位的个数是奇数还是偶数。

方法一

	//利用前面实例二中的方法一。
	int c = 0;
	char a = 0xAF; //二进制表示为 1010 1111
	while (a) {
		a = a & (a - 1);
		c++;
	}
	printf("%d\n", c % 2);

方法二

	//采用和实例二中类似的思想进行求解
	x = x | (x >> 1);
	x = x | (x >> 2);
	x = x | (x >> 4);
	x = x | (x >> 8);
	x = x | (x >> 16);
	printf("%d\n", x & 1);
 	/*对于奇数 i ，x = x | (x >> 1) 的意思判断第 i 位和第 i + 1 为一共有偶数个还是奇数 1 。
	并将结果存储在第 i 位。 对于接下来的式子作类似分析，直到最后一个式子判断高 16 位和
	低 16 位一共有偶数个还是奇数个 1 。并将结果存储在低 16 位。 */ 

<div class="blank"></div>
#####实例四#####
给点位置 p1 和 p2 。（设最低位为第 0 位）将一个数的二进制表示中 p1 后的 n 位和 p2 后的 n 位交换。（假设中间没有重叠）

	int xor = (x >> p1) ^ (x >> p2) & (1 << n) - 1;
	x = x ^ (xor << p1) ^ (xor << p2);
 	/*第一句的意思是取 p1 后的 n 位和 p2 后的 n 位进行异或。并将结果存储在 xor 中。
 	第二句的意思是将 xor 与 p1 后的 n 位进行异或得到 p2 后的 n 位。将 xor 与 p2 后
	的 n 位异或得到 p1 后的 n 位。*/

<div class="blank"></div>
#####引用#####

[geeksforgeeks上关于bit algorithm的介绍](http://www.geeksforgeeks.org/fundamentals-of-algorithms/)<br>
[百度百科关于位运算的介绍(别鄙视，这个词条确实比维基详细）](http://baike.baidu.com/view/379209.htm)

<div class="blank"></div>
####未完待续####
