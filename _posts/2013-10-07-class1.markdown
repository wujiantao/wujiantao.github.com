---
title: c++类的介绍一（构造函数，运算符重载，继承）
layout: post
key: f3bf8ecb-5776-4d7a-999f-589de9b2f69e
tags:
  -c++ 
---

<div class="blank"></div>
#####一、c++中class和struct的区别#####
1. class中默认的成员变量和成员函数是私有的。而struct中默认为公有。
2. class的继承默认为私有继承，而struct默认为公有继承。

<div class="blank"></div>
#####二、构造函数#####
c++的构造函数分拷贝构造函数和普通的构造函数，如果类中不声明任何构造函数，默认会有一个普通的空构造函数和一个空拷贝构造函数，同时对于赋值运算符=也有一个默认的函数用来对象之见的内容拷贝。拷贝构造函数的形式为 ClassName (const ClassName &c)，const限定符可以不要。其他形式的构造函数都会当成普通构造函数。通常声明一个类的对象，必须要有一个匹配的构造函数能被调用，否则程序会报错。而对于拷贝构造函数通常会在初始化赋值或者函数参数按值传递的时候进行调用，而这两种情况都是需要用一个对象的内容去初始化另一个对象。

	class Base
	{
		public:
			int v;
			Base () {this->v = 0;}
			Base (int v) {this->v = v;}
			Base (const Base &c)
			{
				this->v = c.v;
				printf("copy constructor\n");
			}
			void operator= (const Base &c)
			{
				this->v = c.v;
				printf("operator overload\n");
			}
	};

	int main()
	{
		Base a(1);
		Base b(a);	//输出copy constructor
		Base c = a;	//输出copy constructor,初始化赋值都调用拷贝构造函数，其他的调用=函数
		b = a;		//输出operator overload
	}


<div class="blank"></div>
#####三、运算符重载#####
简单起见，可以将运算符看成类的一个成员函数。如下所示

	class Base
	{
		public:
			string name;
			Base (string n) {this->name = n;}
			void operator=(const Base &c)
			{
				cout << this->name << " = " << c.name << endl;
			}
			Base operator + (const Base &c)
			{
				return Base(this->name + " + " + c.name);
			}
	};

	int main()
	{
		Base A("a"), B("b"), C("c");
		A = B + C;
		//函数的调用顺序是，首先对象B调用自己的+运算符，并将对象C作为实参。
		//然后对象A调用自己的=函数，并将先前+函数的返回值作为实参。最后的输出就是a = b + c
	}

<div class="blank"></div>
#####四、继承#####
c++中的继承方式有三种，分别为公有继承，保护继承和私有继承。如果不加关键字限定继承方式，默认为私有继承

1. 公有继承，在公有继承方式下，派生类继承自基类的公有成员和保护成员，其属性保持不变，原来为公有的仍为公有，原来为保护的仍为保护。但原来基类的私有成员在派生类中是不能访问的。
2. 保护继承，在保护继承方式下，派生类继承自基类的公有成员和保护成员，在派生类中属性都变为保护属性。原来基类中的私有成员派生类不能访问。
3. 私有继承，在私有继承方式下，派生类继承自基类的公有成员和保护成员，在派生类中属性都变为私有属性。原来基类中的私有成员派生类不能访问。

在不同的继承方式下，其基类的成员对派生类和派生类的对象的可见性如下所示

1. 公有继承，在公有继承下，其基类的公有成员和保护成员在派生类中都能访问，但派生类的对象只能访问基类的公有成员，因为基类的公有成员在派生类中是公有的。
2. 保护继承，在保护继承下，其基类的公有成员和保护成员在派生类中都能访问，但派生类的对象不能访问基类的任何成员，因为基类的公有成员和保护成员在派生类中都为保护成员。
3. 私有继承，在私有继承下，其基类的公有成员和保护成员在派生类中都能访问，但派生类的对象不能访问基类的任何成员，因为基类的公有成员和保护成员在派生类中都为私有成员。

<div class="blank"></div>
####未完待续####
