---
title: c++类介绍四（位域）
layout: post
key: 3d6b5850-7223-4114-a1da-52332e5543d8
tags:
  -c++ 
---


####一、字节序####

在介绍位域之前先说一下字节序。在我们通常使用的系统中，多字节的数据都是从低位往高位存储的。比如 2 字节的数据 0x1234，其在低地址存储低位数据 0x34，在高地址存储高位数据 0x12。如下所示，其输出为 0x34 0x12 。

	typedef unsigned char  byte;
	typedef unsigned short ushort;
	int main()
	{
		ushort uv = 0x1234;
		byte *p = (byte *)(&uv);
		printf("0x%2x 0x%2x\n", *p, *(p + 1));
	}

其实如果按二进制展开，这两个字节中每比特的数据存储应是按下面的顺序存储的

> 存储顺序 0010 1100 0100 1000 -> 倒序即为 0001 0010 0011 0100 ，即 0x1234的二进制表示

具体的字节序可以参看[维基百科](http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)上的介绍。

####二、位域####

类和结构体中可以包含比特长度比整型变量小的成员，通常将这些成员称之为位域。

位域的定义通常为 类型名 位域名 : 比特长度，其中位域名可有可无，当没有位域名时，该位域通常用来填充相应的位。但无法被引用。同时位域的存储也是按声明的顺序从低地址向高地址存储。如下所示，程序的输出为 4 3 2 1，即先声明的位域其内容存储在低地址。因为我们从上面的字节序介绍可以知道，4 是存储在低地址的，而 1 存储在高地址。

	typedef unsigned char  byte;
	typedef unsigned short ushort;
	union un //联合类型就是其里面定义的变量共用同一块存储空间，比如下面的 num 和 v 共用 2 个字节
	{
		struct num
		{
			ushort	four : 4; //比特长度可以是0-16，但不能超过16。
			ushort	three : 4;
			ushort	two : 4;
			ushort	one : 4;
		}d;
		ushort v;
	} u;

	int main()
	{
		u.v = 0x1234;
		printf("%1x %1x %1x %1x\n",u.d.four, u.d.three, u.d.two, u.d.one);
	}

下面再结合 msdn 上面的两个实例，说明位域中另外两个需要注意的问题。

	typedef unsigned short ushort;
	struct Date
	{
		ushort	nWeekDay : 3;
		ushort	nMonthDay: 6;
		ushort	nMonth : 5;
		ushort	nYear  : 8;
	};

其中Date类型的内存布局如下图所示

![bit field](/media/files/2013/10/08/bit_field1.png)

其中 nYear 和 nMonth之间有两个比特的空格需要注意，这是因为上一个 ushort 只剩下 2 比特了，但 nYear 需要 8 比特的空间来存储，位域又是不能跨字节（指不同整型的字节）存储的。所以 nYear 从一个新的整型开始存储。

对于如下声明的位域，在其结构体中包含一个没有位域名且长度为 0 的位域，其中长度为 0 的位域是强制对齐到下一个整型的开始处。也就是下一个声明的位域要用一个新的整型开始存储。

	typedef unsigned short ushort;
	struct Date
	{
		ushort	nWeekDay : 3;
		ushort	nMonthDay: 6;
		ushort		: 0;
		ushort	nMonth : 5;
		ushort	nYear  : 8;
	};

其中 Date 类型的内存布局如下图所示

![bit field](/media/files/2013/10/08/bit_field2.png)
