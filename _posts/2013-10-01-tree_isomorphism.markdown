---
title: 树的同构判断
layout: post
key: fb278cf7-424a-4d28-9ff0-dc6a845236cb
tags:
  -algorithm
  -data_structure
---

给定两棵树，判断其是否同构。
####二、直接枚举####
方法一，就是直接枚举，判断一个树是否同构。可以转化为判断是否存在一个一一对应的子树对。使得每个子树对之间互相的同构。具体比对时可以进行剪枝，比如额外记录子树的节点数或者深度等特征。那么节点数不等或者深度不等的树肯定是不同构的，可以直接跳过该比对。但这种方法复杂度高，为指数级。

####一、符号表示排序法####
方法二，就是将树转化为符号表示,例如三个点，其中两个子节点，一个父节点且节点层数为两层的树可以表示为( () ())，具体判断方法是先将子树用符号法表示。然后对子树的符号表示按字典顺序进行排序。最后根据子树的符号表示，得出以当前节点为根节点的树的符号表示。例如假设排序后子树的符号表示如果为 T1 T2 ... Tn ，那么当前节点的符号表示就可以表示成 (T1 T2 ... Tn)。最后要判断整棵树是否同构，就判断两棵树的符号表示是否相同。

当然这样判断的正确性基础就是一棵树按上述方法排序后他只能有唯一的符号表示。同时一个符号表示也只能对应一棵树。如果上面其中一条不成立, 那么这种判断也是不成立的。但网上没找到证明。不敢断定正确性,，先记录在这。
