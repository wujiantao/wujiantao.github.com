---
title: c++中的引用类型
layout: post
key: 839952ef-98fd-4166-b144-cc1f67272204
tags:
  -c++
---

引用类型通常可以看成某个变量的一个别名。任何对引用类型的修改，都会反应在其引用的变量中。

	//举个最简单的例子
	int x = 0;
	int &ref = x;
	ref =  1;	//此处对ref的赋值就是对x的赋值。x = 1


####引用类型在类中的使用####

#####1.拷贝构造函数#####

在一个类中，是不允许声明其自类型的对象的，但允许出现其自类型的指针或者引用。所以在写拷贝构造函数时。就将参数写成引用类型。构造函数中也可以出现其自类型的指针作为参数。但这样该构造函数不会被当作拷贝构造函数，而只会当成普通的构造函数。如下所示。
	
	class A
	{
		public:
			A() {}		//普通的构造函数
			A(A *a) {}	//普通的构造函数
			A(A &a) {}	//拷贝构造函数,在用一个对象初始化另一个对象时会被调用
	}

#####2.函数中参数传递#####

通常如果我们希望在函数内部对外面的值进行修改，最常见的做法就是将需要修改的变量作为实参按引用传递进来。或者将形参写成指针的形式亦可。

同时有时候如果形参是一个对象。并且对象比较大。按值调用就比较费时。因为函数调用会为实参作一个内容相同的拷贝（这里会调用拷贝构造函数）,并将这个拷贝传递到函数里面, 这个拷贝过程需要花费较长时间。如果写成按引用调用，就只会将实参的地址传递进来。不需要作任何拷贝，传值的效率就提高了。但这里也要注意，在函数内部对参数所作的任何修改都会反应到实参上去。

#####3.类中的运行时多态性#####

运行时多态性通常在继承中体现。就是可以在运行时根据实参的类型来决定调用基类的函数还是派生类的函数。如下所示。

	class Base
	{
		public:
			virtual void show()
			{
				printf("Base\n");
			}
	};
	
	class Sub : public Base
	{
		public:
			void show()
			{
				printf("Sub\n");
			}
	}

	void show(Base &b)
	{
		b.show();
	}

	int main()
	{
		Base b;
		Sub  s;
		show(b); //输出为Base
		show(s); //输出为Sub
	}

注意上面基类和子类中的成员函数show()需要声明为虚函数。具体原因可以参看关于[虚函数的介绍](../07/virtual_function.html)。同时上面的引用类型也可以换成指针类型。

####引用类型和指针的对比####

> 1. 引用类型必须要初始化，但指针可以不用初始化。
> 2. 引用类型在初始化对某一个变量进行引用后，不能再对其他变量进行引用。但指针指向一个值之后，还可以指向另一个同类型的值。
