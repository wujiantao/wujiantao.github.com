---
title: c++类介绍二（类模板）
layout: post
key: f1fc04c4-361a-44cc-afa8-2fd516c6f1e2
tags:
  -c++ 
---


类模板在平时应该接触的比较多，因为STL中很多应用就是以类模板的形式定义的，比如 vector<int\> v; 这就是用int类型去实例化一个vector的类模板。

#####1.声明和实例化#####
和函数模板的声明类似，类模板也是用 template 关键字来进行声明。然后跟一个尖括号包括的参数列表，参数可以是类型参数，也可以是非类型参数，类型参数用关键字class 或者 typename 声明，非类型参数用普通类型声明。如下所示

	class A
	{
		public:
			static char c; 
			A () { c = 0; }
	};

	//参数列表中第一个为类型参数，后面三个为非类型参数
	template <class T, int i, char *s, char *c>
	class Template
	{
		private:
			T v;
		public:
			Template (T v)
			{
				this->v = v;
			}
	};

	char s;
	int main()
	{
		Template<int, 0, &s, &A::c> (2);
		return 0;
	}

其中非类型参数只能是长整型（包括枚举类型）、所有类型的指针或者所有类型的引用。在实例化时，对长整型的非类型参数必须用常量表达式去实例化，对指针类型或者引用类型的非类型参数需要有外部链接（这里我对外部链接的理解也是模棱两可，例如 s 写在 main 函数里面是通不过编译的，需写在外面, 同时如果 s 是某个类的静态变量，也是可以的。我的片面理解就是需要 s 在函数外面仍然可以被访问到）。

#####2.类模板作为类型指示符#####

类模板作为另一个类模板的类型指示符时，需要声明为指针类型或者引用类型，同时实例化和上面的说明类似，即需要有外部链接。

	template <class type>
	class T1 {};

	template <class type1, T1<type1>& t1>
	class T2 {};

	char s;
	T1<int> t1;
	int main()
	{
		T2<int, t1> t2;
		return 0;
	}
	
#####3.类模板的成员函数#####

类模板的成员函数定义和函数模板的定义类似，也是先用 template关键字声明，尖括号包括参数列表，如下所示。

	template <class T = int>
	class Template
	{
		private:
			T v;
		public:
			Template (T v);
	};

	template <class T>
	Template<T>::Template (T v)
	{
		this->v = v;
	}

上面在类模板的定义中加入了缺省的参数，注意当参数列表中有多个参数时，缺省的顺序是从右往左，即必须先对右边的参数设定缺省值，才能对左边的参数设定缺省值。这里成员函数定义时参数列表中不用写缺省值。
